//#define ARM_MATH_CM3
//#include <arm_math.h>
#include <CMSIS_DSP.h>
#define TOGGLE(x) digitalWrite(x, digitalRead(x) ? LOW : HIGH)
#define NUMPOINTS  600 
#define TAPS 133

HardwareTimer *timer = new HardwareTimer(TIM1);
static unsigned int SampleCounter = 0;
float32_t Voltage_Queue[NUMPOINTS+TAPS];
float32_t Current_Queue[NUMPOINTS+TAPS];
float32_t FVoltage_Queue[NUMPOINTS+TAPS+TAPS];
float32_t FCurrent_Queue[NUMPOINTS+TAPS+TAPS];
bool DataReady, Phase=0;
unsigned n;

/*
const float32_t Coeff[46] = {  // 50Hz +/- 10Hz, -60dB @35, 65Hz
   0.009438431822, -0.01206113491, -0.01230899617, -0.01106051169,-0.006429966539,
  -0.0004818683374, 0.002682675375,0.0005376029876,-0.004928680602,-0.007400613744,
  -0.0002142711019,  0.01797732897,  0.03979805857,  0.05122039467,   0.0391035229,
  0.0004549302394, -0.05259760097, -0.09623703361,  -0.1060419753, -0.07074403763,
  -0.0002440255194,   0.0770246312,   0.1270557493,   0.1270557493,   0.0770246312,
  -0.0002440255194, -0.07074403763,  -0.1060419753, -0.09623703361, -0.05259760097,
  0.0004549302394,   0.0391035229,  0.05122039467,  0.03979805857,  0.01797732897,
  -0.0002142711019,-0.007400613744,-0.004928680602,0.0005376029876, 0.002682675375,
  -0.0004818683374,-0.006429966539, -0.01106051169, -0.01230899617, -0.01206113491,
   0.009438431822 };  

*/
const float32_t Coeff[133] = {    // 60Hz +/- 10Hz, -60dB @ 45, 75Hz
  0.0004461921926, 0.001374978456,0.0006562813651,0.0004494137538,-0.0005042574485,
  -0.001415269799,-0.002017954597,-0.001842695288,-0.0007797637954,0.0009095030255,
   0.002585740527, 0.003481952008, 0.003043584991, 0.001233802992,-0.001363424119,
  -0.003726662602,-0.004811057821,-0.004029974341,-0.001566214371, 0.001644647215,
    0.00429247506,  0.00526703475, 0.004173839465, 0.001525912317,-0.001489804476,
  -0.003579565091,-0.003967781551,-0.002758253831,-0.0008404092514,0.0006322716363,
   0.000912471558,0.0001166245274,-0.0008196087438,-0.0007021790952, 0.001114885206,
   0.004131626803, 0.006714667194,  0.00682254741, 0.003167255083, -0.00377616589,
   -0.01151607838, -0.01634546556,  -0.0149926329,-0.006415365264, 0.007161243819,
    0.02063006721,  0.02788117155,  0.02449485287,  0.01008653454, -0.01086706575,
   -0.03032852523, -0.03979862109, -0.03401838988, -0.01365579572,  0.01434411854,
    0.03912830725,  0.05022572353,  0.04203224927,  0.01653676853, -0.01700974256,
   -0.04553003609,  -0.0573591888, -0.04713052511, -0.01821746863,  0.01838578098,
    0.04837437347,  0.05989545584,  0.04837437347,  0.01838578098, -0.01821746863,
   -0.04713052511,  -0.0573591888, -0.04553003609, -0.01700974256,  0.01653676853,
    0.04203224927,  0.05022572353,  0.03912830725,  0.01434411854, -0.01365579572,
   -0.03401838988, -0.03979862109, -0.03032852523, -0.01086706575,  0.01008653454,
    0.02449485287,  0.02788117155,  0.02063006721, 0.007161243819,-0.006415365264,
    -0.0149926329, -0.01634546556, -0.01151607838, -0.00377616589, 0.003167255083,
    0.00682254741, 0.006714667194, 0.004131626803, 0.001114885206,-0.0007021790952,
  -0.0008196087438,0.0001166245274, 0.000912471558,0.0006322716363,-0.0008404092514,
  -0.002758253831,-0.003967781551,-0.003579565091,-0.001489804476, 0.001525912317,
   0.004173839465,  0.00526703475,  0.00429247506, 0.001644647215,-0.001566214371,
  -0.004029974341,-0.004811057821,-0.003726662602,-0.001363424119, 0.001233802992,
   0.003043584991, 0.003481952008, 0.002585740527,0.0009095030255,-0.0007797637954,
  -0.001842695288,-0.002017954597,-0.001415269799,-0.0005042574485,0.0004494137538,
  0.0006562813651, 0.001374978456,0.0004461921926
}; 
/*
const real32_t Coeff[133] = {   //50Hz +/- 10Hz, -60dB @ 35, 65Hz.
   0.001103623887,0.0006575306179,0.0004692933871,-3.401126378e-05,-0.0007715929532,
  -0.001539104036,-0.002055359073,-0.002052887343,-0.001385550015,-0.0001125940908,
   0.001476804959, 0.002921934938, 0.003723074915, 0.003512228141, 0.002203492913,
  6.315654173e-05,-0.002336925128,-0.004280502908,-0.005135930609,-0.004577741493,
  -0.002718874021,-9.702011448e-05, 0.002492691856, 0.004265680443, 0.004722393118,
   0.003828156274, 0.002024887362,5.620687807e-05,-0.001331936219,-0.001700444845,
  -0.001109516132,-0.0001135315833,0.0004788348742,-2.559063068e-05, -0.00182874559,
  -0.004432952963,-0.006718328223,-0.007310901769, -0.00514795864,-2.65644012e-05,
   0.007080986165,  0.01412692014,  0.01852925122,   0.0180315841,  0.01160406135,
  6.162426143e-05,   -0.013875423, -0.02618323267, -0.03268512338,  -0.0304203555,
   -0.01879266277,-7.741306763e-05,  0.02095428295,  0.03826837987,  0.04633194581,
    0.04188711569,  0.02515823022,6.218498311e-05, -0.02671968006, -0.04758458585,
   -0.05624409765, -0.04967226461, -0.02914630249,-2.39861165e-05,  0.02971525677,
    0.05175569654,  0.05986978859,  0.05175569654,  0.02971525677,-2.39861165e-05,
   -0.02914630249, -0.04967226461, -0.05624409765, -0.04758458585, -0.02671968006,
  6.218498311e-05,  0.02515823022,  0.04188711569,  0.04633194581,  0.03826837987,
    0.02095428295,-7.741306763e-05, -0.01879266277,  -0.0304203555, -0.03268512338,
   -0.02618323267,   -0.013875423,6.162426143e-05,  0.01160406135,   0.0180315841,
    0.01852925122,  0.01412692014, 0.007080986165,-2.65644012e-05, -0.00514795864,
  -0.007310901769,-0.006718328223,-0.004432952963, -0.00182874559,-2.559063068e-05,
  0.0004788348742,-0.0001135315833,-0.001109516132,-0.001700444845,-0.001331936219,
  5.620687807e-05, 0.002024887362, 0.003828156274, 0.004722393118, 0.004265680443,
   0.002492691856,-9.702011448e-05,-0.002718874021,-0.004577741493,-0.005135930609,
  -0.004280502908,-0.002336925128,6.315654173e-05, 0.002203492913, 0.003512228141,
   0.003723074915, 0.002921934938, 0.001476804959,-0.0001125940908,-0.001385550015,
  -0.002052887343,-0.002055359073,-0.001539104036,-0.0007715929532,-3.401126378e-05,
  0.0004692933871,0.0006575306179, 0.001103623887
};   */

void UpdateData(void) {
  //TOGGLE(PC13);
  if (SampleCounter <= NUMPOINTS) {
    Voltage_Queue[SampleCounter] = (float32_t)analogRead(PA0);
    Current_Queue[SampleCounter] = (float32_t)analogRead(PA1);
    }
  if (SampleCounter==NUMPOINTS) {
         timer->pause();
         //Serial.print("Samples Acquired: ");
         //Serial.println(SampleCounter);
         DataReady = true;
         digitalWrite(PC13,0);
         digitalWrite(PB8,0);
         }
    if (SampleCounter < NUMPOINTS) SampleCounter++;
    }
    
void setup() {
 Serial.begin(115200);
 digitalWrite(PC13,0);
 digitalWrite(PB12,0);
 digitalWrite(PB8,0);
 digitalWrite(PB9,0);
 pinMode(PB8,OUTPUT);
 pinMode(PB9,OUTPUT);
 pinMode(PC13,OUTPUT);
 pinMode(PB12, OUTPUT);
 noInterrupts();
 TIM_TypeDef *inst = TIM1;
 timer = new HardwareTimer(inst);
 timer->pause();
 timer->setOverflow(600, HERTZ_FORMAT);
 timer->attachInterrupt(UpdateData);
 timer->refresh();
 timer->resume();
 analogReadResolution(12);
  
}

void loop() {
  uint16_t i;
  DataReady = 0;
  SampleCounter = 0;
  digitalWrite(PB12,0);
  float32_t Vrms, Irms, InPhase, OutPhase, Power;
 static float32_t firStateF32[NUMPOINTS+TAPS-1];
 arm_fir_instance_f32 S;
 arm_fir_init_f32(&S, TAPS, (float32_t *)&Coeff[0], &firStateF32[0], NUMPOINTS);
  interrupts();
  while (1) {
    while (!DataReady) n=n+2;  // Wait for Data Capture.
    arm_fir_f32(&S, &Voltage_Queue[0], &FVoltage_Queue[0], NUMPOINTS);
    arm_fir_f32(&S, &Current_Queue[0], &FCurrent_Queue[0], NUMPOINTS);
    arm_rms_f32(&FVoltage_Queue[TAPS], (NUMPOINTS), &Vrms);
    arm_rms_f32(&FCurrent_Queue[TAPS], (NUMPOINTS), &Irms);
    //Vrms *= 0.00100;  // Voltage Cal factor
    //Irms *= 0.00100;  // Current Cal Factor
    InPhase = 0.0;
    OutPhase = 0.0;
    for (i=0; i<100; i++) {
      InPhase += (FVoltage_Queue[i] * FCurrent_Queue[i]);
      OutPhase +=(FVoltage_Queue[i] * FCurrent_Queue[i+5]);
    }
    InPhase /= 100.0;
    OutPhase /= 100.0;
    if (InPhase > OutPhase) 
      { 
      Phase = false;
      digitalWrite(PB9,1);
    Irms = -Irms;
    }
    else 
    { Phase = true;
      digitalWrite(PB9,0);
      }
    Power = (Vrms * Irms) / 1000.0;
    //Serial.print(InPhase);
    //Serial.print(",");
    //Serial.print(OutPhase);
    //Serial.print(",");
    Serial.print(Vrms);
    Serial.print(", ");
    Serial.print(Irms); 
    Serial.print(", ");
    Serial.println(Power);
    
/*    for (n=100; n<600; n++) {
         Serial.println(FVoltage_Queue[n]);
         //Serial.print(",");
         //Serial.print(-1000);
         //Serial.print(",");
         //Serial.println(2200);
         }  
*/  
      //Serial.println(FCurrent_Queue[n]);
    SampleCounter = 0;
    DataReady = false;
    digitalWrite(PC13,1);
    digitalWrite(PB8,1);
    timer->resume();
    }

  }
